%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% CL provided template
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[12pt,a4paper,oneside,openright]{report}

% makes subsubsections appear in the toc
\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{3}

% turns references into hyperlinks
\usepackage[pdfborder={0 0 0}]{hyperref}
\newcommand{\URL}[1]{\href{https://#1}{\textcolor{cyan}{\texttt{#1}}}}


% adjusts page layout
\usepackage[margin=25mm]{geometry}

% allows inclusion of PDF, PNG and JPG images
\usepackage{graphicx}
\graphicspath{ {figs/} }

\usepackage{verbatim}

% try to avoid widows and orphans
\raggedbottom
\sloppy
\clubpenalty1000%
\widowpenalty1000%

% adjust line spacing to make more readable
\renewcommand{\baselinestretch}{1.1}

% add colour to TODOs
\usepackage{xcolor}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Maths
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage{amsmath}        % American Mathematical Society
\usepackage{amssymb}        % Maths symbols
\usepackage{amsthm}         % Theorems
\usepackage{mathpartir}    % Proofs and inference rules

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Floats
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage{float}
\usepackage[labelfont=bf,margin=10pt]{caption}
\usepackage{subcaption}
\newcommand{\mycaption}[2]{\caption[#1]{#1 #2}}

\floatstyle{plain}
\restylefloat{figure}
\restylefloat{table}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
% Figures
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage{tikz}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Tables
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage{array}
% control width and vertically align text in table cells
\newcolumntype{L}[1]{>{\raggedright\let\newline\\\arraybackslash\hspace{0pt}}p{#1}}
\newcolumntype{C}[1]{>{\centering\let\newline\\\arraybackslash\hspace{0pt}}p{#1}}
\newcolumntype{R}[1]{>{\raggedleft\let\newline\\\arraybackslash\hspace{0pt}}p{#1}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Listings
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage{fancyvrb}

\floatstyle{boxed}
%\floatstyle{ruled}
\newfloat{Listing}{tbp}{lol}[chapter]

\DefineVerbatimEnvironment{JavaCode}{Verbatim}
{fontfamily=courier,baselinestretch=1,gobble=4}

\DefineVerbatimEnvironment{GoCode}{Verbatim}
{fontfamily=courier,baselinestretch=1,gobble=4}

\usepackage{listings}
\usepackage{color}
\usepackage{mathtools}

\definecolor{dkgreen}{rgb}{0,0.4,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{
  language=Java,
  aboveskip=0mm,
  belowskip=0mm,
  showstringspaces=false,
  %columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=left,
  keywordstyle=\bfseries,
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=4
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Semantic and convenience macros
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\TOBEDONE}{{\LARGE To be done...}}
\newcommand{\todo}[1]{\textcolor{red}{TODO: #1}}
\newcommand{\note}[1]{\textcolor{blue}{NOTE: #1}}

\newcommand{\javaLiteral}[1]{\texttt{#1}}
\newcommand{\javaCode}[1]{\texttt{#1}}
\newcommand{\javaClass}[1]{\texttt{#1}}
\newcommand{\javaSlot}[1]{\texttt{#1}}
\newcommand{\javaVariable}[1]{\texttt{#1}}
\newcommand{\javaKeyword}[1]{\texttt{#1}}
\newcommand{\javaMethod}[1]{\texttt{#1}}
\newcommand{\javaException}[1]{\texttt{#1}}
\newcommand{\javaAnnotation}[1]{\texttt{#1}}

\newcommand{\goCode}[1]{\texttt{#1}}
\newcommand{\goType}[1]{\texttt{#1}}
\newcommand{\goValue}[1]{\texttt{#1}}
\newcommand{\goVariable}[1]{\texttt{#1}}
\newcommand{\goKeyword}[1]{\texttt{#1}}
\newcommand{\goFunc}[1]{\texttt{#1}}

\newcommand{\keyTerm}[1]{\textbf{#1}}

\newcommand{\codeemph}[1]{\textbf{#1}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Info about dissertation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\disstitle}{Software Transactional Memory implementation
  and benchmarking in Go}
\newcommand{\college}{Churchill College}
\newcommand{\studentname}{Rui Cachopo}
\newcommand{\candidatenumber}{2399F} %checked Moodle on 25/04/2020
\newcommand{\studentemail}{rmc82@cam.ac.uk}
\newcommand{\wordcount}{0000}
\newcommand{\loc}{0000}
\newcommand{\originator}{\candidatenumber}
\newcommand{\supervisor}{Tim Harris}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Start of document
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\bibliographystyle{apalike}

\pagestyle{empty}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Cover page
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\rightline{\LARGE \textbf{\studentname}}

\vspace*{60mm}
\begin{center}
  \Huge
  \textbf{\disstitle} \\[5mm]
  Computer Science Tripos -- Part II \\[5mm]
  \college \\[5mm]
  \today
\end{center}

\newpage

\section*{Declaration}

I, \studentname\ of \college, being a candidate for Part II of the
Computer Science Tripos, hereby declare that this dissertation and the
work described in it are my own work, unaided except as may be
specified below, and that the dissertation does not contain material
that has already been used to any substantial extent for a comparable
purpose.

I, \studentname\ of \college, am content for my dissertation to be
made available to the students and staff of the University.

\bigskip \leftline{Signed: }

\medskip \leftline{Date: \today}


\chapter*{\vspace{-1.2in} Proforma \vspace{-0.3in}}

\thispagestyle{empty}

{ \begin{tabular}{L{0.3\linewidth} L{0.7\linewidth}}
    \textbf{Candidate number:} & \candidatenumber                      \\
    \textbf{Project Title:}           & \disstitle \\
    \textbf{Examination:}        & Computer Science Tripos -- Part II, July 2020  \\
    \textbf{Word Count:}         & \wordcount  \\
    \textbf{Lines of code:} & \loc \\
    \textbf{Project Originator:} & \originator \\
    \textbf{Supervisor:} & \supervisor \\
  \end{tabular}
}

\section*{Original Aims of the Project}

The core goals of the project were to implement a Software
Transactional Memory and to make a meaningful evaluation of the system
produced. This evaluation involves both quantitative benchmark results
and qualitative results related to the usability of the system. The
technical deliverables are implementations of the STM and the
benchmark produced --- as there is no existing realistic benchmark in
the language chosen for this project. The qualitative results of the
evaluation can be found in the evaluation chapter of this
dissertation.

\section*{Work Completed}

All the success criteria of the project have been met. I implemented
the Go Versioned Software Transactional Memory and demonstrated its
correctness and performance by producing an implementation of the
STMBench7 benchmark and accompanying tests. Due to the difficulties
described in the section below I had much less time than I had hoped
to work on extension tasks.

The completion of this work required substantial research into
Transactional Memory and Go's concurrency primitives and memory
model. Implementation of an application as large as the STMBench7
benchmark also required knowledge and use of software engineering
patterns and practices.

\section*{Special Difficulties}

In November 2019 I had a climbing accident that resulted in a
dislocated elbow. This halted project work, and in fact all academic
work, for a few weeks until I was able to use a keyboard again.

Starting in March 2020, the COVID-19 pandemic forced me, and indeed
the vast majority of students, to work from home for the rest of the
academic year. This meant that the last month of work on the project
and this dissertation were completed in an environment much less
productive than expected.

\newpage

\pagestyle{plain} \pagenumbering{roman}

\tableofcontents

\listoffigures{}

\listoftables{}

\listof{Listing}{List of Listings}

\newpage

\section*{Acknowledgements}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% #Content
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\pagestyle{headings}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Intro
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Introduction}

\pagenumbering{arabic}

This dissertation describes the implementation and benchmarking of a
Software Transactional Memory (STM) in Go, a programming language that
emerged just as research on STMs dwindled. In this chapter I aim to
give a brief historical background of STMs and explain the choices I
made when proposing the project. In particular, I explain the choice
of STM algorithm, programming language and benchmark to use.

\section{Motivation and previous work}
\label{sec:motivation}

To have some context on the motivations behind STMs, it makes most
sense to first remember the historical trends in processor
design. From there, we can see how modern hardware limitations caused
a revolution in software and the problems that this caused to
programmers. Finally, we can see how STM tackles these problems.

\subsection{The problem}
\label{sec:problem}

In the last few decades, and especially in the period of 1986--2003,
single-core processor performance grew exponentially at such a rate
that hardware became obsolete within one or two years. This was mostly
thanks to two ``laws'' of processor design: Moore's law
\cite{MooreLaw} and Dennard scaling \cite{DennardScaling}. Moore's law
is the observation that, due to the production of smaller transistors,
the number of transistors in a processor doubles every two
years. Although the prediction in the 1965 paper was a doubling in
transistor count every year, this was revised in 1975 to a doubling
every two years. Dennard scaling states that as transistors get
smaller and consume less power, their power density stays constant, so
the power consumption of the whole processor remains constant.

The combination of these laws impacts processor performance in three
main ways:

\begin{itemize}
\item Smaller transistors can switch faster, meaning that the clock
  frequency of the processor can be increased.
  
\item The higher transistor budget allows for more complex hardware
  design. One way this was exploited was the use of pipelining, which
  reduces the critical path inside processor and allows the clock
  frequency of the processor to increase.
  
\item More complex hardware design was also used to build
  out-of-order, superscalar processors. These processors could exploit
  Instruction Level Parallelism (ILP) \cite[Chapter~3]{CompArchBook}
  latent in most programs.
\end{itemize}
This processor performance ``free lunch'' \cite{FreeLunchIsOver} ended
in the early 2000s, when Dennard scaling ceased to hold and the
low-hanging fruit of processor design had been harvested:

\begin{itemize}
\item In post-Dennard scaling, power consumption becomes a limiting
  factor in the complexity of a single core and on the clock frequency
  of the processor.
  
\item The performance penalties caused by processor stalls, such as
  cache misses and mispredicted branches, increases with the length of
  the processor pipeline. This means deeper pipelines yield
  diminishing returns.
  
\item The amount of ILP latent in most programs is limited. This means
  that increasingly complex superscalar hardware will also yield
  diminishing returns.
\end{itemize}
As the limits of single-core performance and latent ILP were reached,
processor designers shifted their focus to multicore processors, which
are capable of exploiting Thread Level Parallelism (TLP)
\cite[Chapter~5]{CompArchBook}. As opposed to ILP, which can be
automatically exploited by the processor in most applications, TLP
usually requires the program to be written using multiple
threads. This means that the burden is now on programmers to write
concurrent applications if they want to reap the benefits of
increasing processor performance. Enter the software revolution
towards concurrent programming.

\subsection{Possible solutions}
\label{sec:possible-solutions}

\paragraph{Locking.} The model most commonly used in concurrent
programs consists of multiple threads, which communicate through
access to shared memory. Low level primitives such as locks are used
to provide condition synchronisation and mutual exclusion when
accessing shared resources. This model is sufficient for simple
programs, but it does not scale to large applications. Problems such
as deadlock and priority inversion are hard to detect and debug in
large programs. The lack of a semantic link between a mutex lock and
the resource it protects leads to what Herlihy and Shavit call
``synchronisation by convention'' \cite[Chapter
18]{ArtMultiprocessorProgramming}.

\begin{Listing}[hbtp]
\begin{lstlisting}
/* When a locked buffer is visible to the I/O layer BH_Launder
 * is set. This means before unlocking we must clear BH_Launder,
 * mb() on alpha and then clear BH_Lock, so no reader can see
 * BH_Launder set on an unlocked buffer and then risk to
 * deadlock.
 * /
\end{lstlisting}

  \mycaption{Synchronisation by convention.}{This Linux kernel comment
    demonstrates how real-world concurrent systems rapidly become
    complex.}
  \label{lst:syncConv}
\end{Listing}


\paragraph{Monitors and condition variables.} Several approaches have
been suggested as solutions to the problems present when using locks
and shared memory. The most basic of these is the use of slightly
higher level primitives, such as monitors and condition
variables. Java is a good example of this: the JVM associates one
monitor and one condition variable with each object. A
\javaKeyword{synchronized} code block runs inside a monitor, which can
be used to provide mutual exclusion. The condition variables can be
used for condition synchronisation using the \javaMethod{wait},
\javaMethod{notify} and \javaMethod{notifyAll} methods.

\paragraph{Message passing.} Moving away from threads and shared
memory, other concurrency models have been created. The most
widespread involve message passing between strongly isolated processes
--- so called because, unlike threads, they do not share
memory. Hoare's Communicating Sequential Processes \cite{CSP} and
Milner's Calculus of Communicating Systems \cite{CCS} are two formal
models that use this idea. These models are mostly employed by
functional programming languages such as Erlang, which allow no shared
memory and in which all data is immutable. Concurrent programs in
these languages can be simpler to write and debug, but often do not
perform as well as programs written in more ``traditional'' languages
such as Java and C\texttt{++}.

\paragraph{Transactional memory.} Yet another approach, and the focus
of this dissertation, is Transactional Memory (TM) \cite{TMBook}. When
using transactional memory, a programmer organises their code into
transactions, similar to the transactions in the transactional model
of databases. It is then up to the underlying TM implementation to
provide atomicity and isolation of the transactions executed. That is,
the memory operations of each transaction executed appear to occur
atomically, and no transaction can see the results of a partial
execution of any other transaction.

\subsection{Transactional memory}
\label{sec:transactional-memory}

Transactional memories provide a very simple interface to programmers:
to write a correct concurrent program, place all parallel code that
accesses shared data inside transactions, and let the underlying TM
ensure the program is correctly synchronised. Transactional memories
also provide composability, meaning it is simple to compose existing
transactions to achieve more complex behaviour. As an example,
consider that we want to dequeue an element from a concurrent queue
$Q_1$ and enqueue it in concurrent queue $Q_2$, but without any other
thread observing that the element is in neither or both queues at the
same time. Attempting to solve this problem with locks would be fairly
complex, involving either additional locks or exposing the internal
locking logic of the concurrent queues. In a TM model, however, the
solution is trivial: simply execute both operations in the same
transaction.. This is discussed in more depth in Section
\ref{sec:prep:techn-requ}.

Transactional memories can be implemented in hardware or
software. Hardware Transactional Memories (HTM) \todo{citation} are
usually implemented on top of the cache coherence protocol of a
processor, and are offered as an Instruction Set Architecture (ISA)
extension. Because they operate at such a low level, HTMs are often
very efficient, but the size of transactions is limited by the size of
cache available and the implementation cost is extremely
high. Software Transactional Memories (STM) \cite{STM} are much more
flexible, but implementing them efficiently can be a
challenge. Efficiency concerns with regards to STMs are so great that
they have been called a ``research toy'' \cite{Toy}.

\section{Golang}
\label{sec:intro:golang}

In this project I aim to implement an STM and evaluate its
performance. I have chosen to do this in Go\footnote{\URL{golang.org}}
because it is a language that emerged after the wave of research on
STMs in the early 2000s, and so there is no exploration of how the
language's features can be exploited to increase the applicability of
STM approaches. Additionally, Go is designed with concurrency as a
primary focus. In fact, one of the primary uses of Go has been to
build server applications, and there is a growing environment of tools
and libraries to support this. Examples are Docker and Kubernetes
implementations, the etcd key-value store
system\footnote{\URL{etcd.io}}, the Elasticsearch-Logstash-Kibana
stack for logging\footnote{\URL{elastic.co/what-is/elk-stack}} and
Prometheus for metric tracking\footnote{\URL{prometheus.io}}. One of
my goals when choosing to use Go for this project was to eventually
contribute to this environment, and make it easy for software
engineers to build server applications using STM.

% Go, sometimes referred to as Golang, is a language whose development
% started in 2007 in Google, and which was released in 2012. Go was
% designed with a focus on writing concurrent programs. Its
% concurrency model is based on Hoare's CSP: multiple goroutines, Go's
% version of coroutines, communicate through channels, which can be
% blocking or buffered. Go also supports shared memory, as well as
% locks and single-word atomic memory operations. The peculiarities of
% Go and their implications on my project are discussed in Section
% \ref{sec:prep:research}.

\section{The STM chosen}
\label{sec:stm-chosen}

Although there has been substantial research on the topic of
transactional memory, and many STMs have been implemented, there are
few applications that actually use them. From a software engineering
perspective, there are many possible reasons for this, such as
adoption costs and little to no support of commonly used libraries. As
one of my goals in choosing my project was to one day develop an STM
that could be adopted in industry, it made sense to base my project on
an existing STM with a real-world application. Such an STM is the Java
Versioned Software Transactional Memory (JVSTM) \cite{jvstm}, which
has been used in the FenixEDU project
\cite{carvalho2008versioned}. Because my STM uses the same version
box--based algorithm \cite{VBox} but is implemented in Go instead of
Java, I have decided to name it Go Versioned Software Transactional
Memory (GVSTM).

\section{Evaluation and benchmarking}
\label{sec:eval-benchm}

Performance is a crucial factor in the evaluation of STMs. Although it
has been shown that STMs can largely outperform sequential code in
multicore computers \cite{MoreThanToy}, it falls to each STM
implementation to show that it is sufficiently efficient to be
adopted. With that goal in mind, it is important for the success of
this project to demonstrate how the STM implemented performs when
compared to alternatives, even if it does not outperform them.

With that in mind, I have chosen to include in the evaluation of my
STM the results of the STMBench7 benchmark, which can be regarded as a
stress test of STMs \cite{STMBench7}. STMBench7 aims to be a realistic
benchmark, meaning that instead of performing a long series of simple
transactions, such as reading and writing a handful of variables, it
performs elaborate operations on complex data structures. A
description of the benchmark and its data structures and operations
can be found in Section \ref{sec:impl:stmbench7}.

As of the start of this project, there is no Go implementation of
STMBench7. This means that a considerable part of the work to be
completed, both in terms of lines of code written and time investment,
will consist of adapting the existing Java version to be implemented
in Go. Because of the complexity and size of the benchmark, my
proposal is to implement a subset of the original 45
operations. Completing the implementation of the benchmark is an
extension goal of the project.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Preparation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Preparation}

I begin this chapter with an overview of my relevant experience and
work completed before the start of the project. I then describe the
requirements of an STM, from both a functional perspective and one of
producing a system that can be adopted in a software engineering
environment. I give an overview of the research conducted to become
familiar with the features of Go that had a significant impact on the
design decisions of this project. In Section
\ref{sec:design-decisions} I refer back to this overview. I conclude
the chapter by describing my engineering methodology, as well as
details of the hardware and software systems used.

\section{Starting point}
\label{sec:prep:starting-point}

Here I summarise knowledge relevant to the project that I acquired
outside of the Computer Science Tripos. Within the Tripos, the courses
most relevant to this project are Part IB Concurrent and Distributed
Systems, which covers the basic shared memory synchronisation
mechanisms, and the Multicore Semantics and Programming Unit of
Assessment, which covers memory models and more advanced
synchronisation mechanisms such as Transactional Memory.

\paragraph{Experience with Go programming.} After Part IB of the
Tripos I completed an internship with Improbable, where I learned Go
and used it to build server applications using the microservice
architecture. My experience with Go here was mostly using both
internal and external libraries, and did not involve using Go's
concurrency primitives explicitly.

\paragraph{Knowledge of the STM algorithm.} I was first introduced to
the concept of Transactional Memory in the last concurrency lecture of
the Part IB Concurrent and Distributed Systems course, which touched
on a few topics. I was intrigued, so I spent some time reading about
transactional memory, and about the JVSTM in particular. This gave me
a good general understanding of the algorithm used, but I did not look
into implementation specifics.

\paragraph{Prototype built for project proposal.} Before proposing
this project to my supervisor I created a prototype of the GVSTM, to
verify that the task I was setting out to do was feasible within the
context of a Part II project. This prototype was just over one hundred
lines of code and lacked some important features such as garbage
collection of old versions. As discussed in Section
\ref{sec:impl:garbage-collection}, this meant that a program using the
GVSTM would quickly run out of memory.

\paragraph{Access to JVSTM and STMBench7 codebases.} The JVSTM
codebase is freely available in its GitHub
repository\footnote{\URL{github.com/inesc-id-esw/jvstm}}. The
STMBench7 benchmark is sadly no longer available at its
homepage\footnote{\URL{dcl.epfl.ch/transactions/wiki/doku.php?id=stmbench7}},
but it is available in the JVSTM benchmarks
repository\footnote{\URL{github.com/inesc-id-esw/jvstm-benchmarks/tree/master/stmbench7}}.

\section{Requirements analysis}
\label{sec:requ-analys}

The requirements of a transactional memory can be divided into
functional and quality requirements. Functional requirements must be
met for a TM to be classed as such and to provide correct
synchronisation. Quality requirements should be met for a TM to be a
viable alternative to other synchronisation mechanisms and to be
adopted by software engineers. In this project I will make sure that
the GVSTM meets the functional requirements. Attempting to ensure that
it also meets quality requirements would involve extensive qualitative
evaluation, such as surveying software engineers with experience
programming using multiple concurrency models, and is far beyond the
scope of this project. It should also be noted that TM has not been
widely adopted in over a decade of research, and changing that would
be an extraordinary achievement for an undergraduate project. That
being said, it is still relevant to consider the quality requirements
in my evaluation of the GVSTM, even though meeting them is not a
priority in the project.

\subsection{Functional requirements}
\label{sec:prep:techn-requ}

\paragraph{ACID properties.} Any transactional memory must provide
Atomicity, Consistency and Isolation according to the ACID properties
of the database transactional model. Atomicity guarantees that each
transaction either commits or aborts fully --- no transaction may
conclude with only some of its memory operations successfully
executed. Consistency guarantees that the result of executing a
transaction on a consistent view of the program will result in a
consistent view of the program. Isolation can be provided to varying
degrees. In the context of the ACID properties, isolation guarantees
that no committed transaction may have seen the results of a partial
execution of another transaction. Durability concerns the resilience
of committed transactions to system failures, often by using
non-volatile storage. Because TM operates only in main memory
durability is not usually a concern.

\paragraph{Opacity.} In practice, modern transactional memories are
expected to make stronger guarantees than those provided by the ACID
properties. Opacity \cite{Opacity} is widely regarded as the
correctness property to be achieved by TMs, and is stronger than
properties imported from the area of database concurrency control such
as serialisability and strict serialisability
\cite{Serialisability}. In summary, opacity strengthens the isolation
condition so that no transaction, including aborted and in-flight
transactions, can access inconsistent states. The GVSTM provides
opacity by only allowing each transaction to access the state
consistent with its read timestamp --- see Section
\ref{sec:impl:vers-data-struct}.

\paragraph{Reading and writing transactional variables.} In the
general case, a transactional memory could provide the properties
above to many kinds of operations, such as I/O and, in the case of Go,
channel communication. Providing such a general solution from scratch,
in addition to implementing a benchmark to meaningfully evaluate it,
would be far beyond the scope of an undergraduate project. As such, I
decided to focus on implementing an STM that provides the properties
above only to reads and writes of transactional variables. Section
\ref{sec:impl:extensions} briefly discusses how the GVSTM could be
extended to handle arbitrary operations transactionally. There is,
however, a case to be made against using different concurrency models
such as TM and channel communication in the same program.

\paragraph{Composability.} One of the most appealing features of STM
when compared to other synchronisation mechanisms is the ease of
composition of transactions. As shown in Listing
\ref{lst:composability}, given transactional methods to add and remove
an element from a queue, a transactional method to move an element
from one queue to another is trivial, as is the creation of an atomic
version of said method.

\begin{Listing}[hbtp]
\begin{lstlisting}
func transactionalEnqueue(queue Q, element E) {...}

func transactionalDequeue(queue Q) E {...}

func transactionalMove(queueOne, queueTwo Q) {
    element := transactionalDequeue(queueOne)
    transactionalEnqueue(queueTwo, element)
}

func atomicMove(queueOne, queueTwo Q) {
    Atomic(func() {
        transactionalMove(queueOne, queueTwo)
    })
}
\end{lstlisting}

  \mycaption{Composability.}{The pseudocode presented here uses syntax
    similar to that of Go, but does not obey the syntax of
    transactional methods defined later in this dissertation.}
  \label{lst:composability}
\end{Listing}


\subsection{Quality requirements}
\label{sec:prep:usab-requ}

\paragraph{Performance.} One of the principal concerns of STM
designers is performance. Depending on the algorithm used, it may be
necessary to keep large read- and write-sets (see section
\ref{sec:impl:read-sets-write}) or perform complex conflict detection
operations, which may introduce significant overheads. For software
engineers to choose to adopt an STM it must demonstrate that its
performance is at least comparable to that of other solutions, in
addition to simplifying the programming model used. Performance may
have different meanings in different applications:
\begin{itemize}
\item Some applications may require an upper bound on the latency of
  any operation.
\item Some applications may prefer to minimise the latency of read
  operations at the cost of increasing the latency of write
  operations.
\item Some applications may try to ensure maximal throughput, while
  giving no guarantees on the performance of individual operations.
\end{itemize}

Of the three examples above, the first is likely to occur in real-time
applications, such as frequency trading or security-critical
applications. Transactional memory is unlikely to be a sensible
solution in these cases. The latter two examples are more likely to
occur in server applications, in which STM is much more promising. The
GVSTM in particular is heavily read-optimised, and guarantees
low-latency read-only operations regardless of the presence of
write-operations. This is discussed in Section
\ref{sec:impl:read-only-trans}.

\paragraph{Usability.} As discussed in Section \ref{sec:problem},
synchronisation using locks is problematic for a number of
reasons. Programming using an STM should not only make it easier to
write correct concurrent programs, but also be easy and intuitive to
use and shorten iteration times for software engineers. Short of
surveying a large number of software engineers with experience
programming using multiple concurrency models, an evaluation of
usability will be somewhat subjective. In Section
\ref{sec:eval:impl-stmb} I give an account of my own experience using
the GVSTM and locking approaches to program parts of STMBench7.

\section{Preliminary research --- features of Go}
\label{sec:prep:research}
\todo{Find a better section title.}

Part of the research necessary to complete this project was to become
familiar with features of Go that are essential to the implementation
of an STM and of a benchmark that is itself a significant software
project. In this section I summarise these features, focusing on where
they differ from Java's, the language originally used to implement the
JVSTM and STMBench7. I will include small code examples, and I
recommend that those unfamiliar with Go read this section. More detail
on these topics can be found in Go's
specification\footnote{\URL{golang.org/ref/spec}} and memory
model\footnote{\URL{golang.org/ref/mem}}.

\subsection{Polymorphism}
\label{sec:prep:polymorphism}

Go, at the time of writing (version 1.14), does not offer generic
programming, but supports polymorphism in the form of interface
types. Interface types declare a set of methods --- an interface. Any
type that implements a superset of the methods of an interface is said
to implement the corresponding interface type, and can be taken at
runtime to be of the interface type. See Listing
\ref{lst:interfaceTypes} for an example.

A particularly interesting interface type is the empty
interface. Because its method set is empty, all types implement
it. This makes it useful for implementing libraries that must support
operations on arbitrary types, because it allows the creation of a
single method that supports all types instead of having distinct
methods for each type. Compared to generic programming this has the
disadvantage of requiring users to explicitly cast values to the
particular types they expect said values to have. This is cumbersome
but, sadly, the best solution available in Go at the moment.

\begin{Listing}[hbtp]
\begin{lstlisting}
type bird interface {
    eat()
}

type duck interface {
    walk()
    quack() string
}

type mallard struct {...}

func (m mallard) eat() {...}

func (m mallard) walk() {...}

func (m mallard) quack() string {...}

type barnacle struct {...}

func (b barnacle) eat() {...}

func (b barnacle) honk() string {...}
\end{lstlisting}

  \mycaption{Interface types.}{Type \goType{mallard} implements
    \goType{duck} and \goType{bird}. Type \goType{barnacle} implements
    \goType{bird} but not \goType{duck}. Both concrete types implement
    the empty interface \goType{interface\string{\string}}.}
  \label{lst:interfaceTypes}
\end{Listing}


\subsection{Object semantics}
\label{sec:prep:oop}

Function arguments in Go are passed by value, including method
receivers. This means that in the example in Listing
\ref{lst:interfaceTypes}, each time a method of the \goType{mallard}
type is called, a copy of the struct is made. If the method changes
some fields of the struct the value held by the parent is
unchanged. In large software projects, and indeed ones ported from an
object oriented language, it is useful to have the concept of an
object, in which updates on an object made by one part of the program
can be seen by other parts.

To get such semantics in Go, it suffices to change the receiver type
of methods to a pointer type. This means that instead of type
\goType{mallard} implementing interface type \goType{duck}, pointer
type \goType{*mallard} implements interface type \goType{duck}. This
is, in practice, more common in Go, and can be seen for example with
the implementations of the \goType{sync.Locker} interface type, which
is the interface implemented by locks.

\subsection{Errors and panics}
\label{sec:prep:panics-errors}

For the sake of brevity, I will assume the reader is comfortable with
Java's exceptions, and with the distinction between checked and
unchecked exceptions. Because exceptions can alter the flow of
execution, they raise some questions with STM implementations:

\begin{itemize}
\item If a transaction causes an exception, should it commit or abort?
\item If the former, will the transaction maintain the consistency
  property mentioned in Section \ref{sec:prep:techn-requ}?
\item If the latter, will the condition that caused the exception
  still hold and be reproducible?
\item Should a transaction be able to raise an exception due to seeing
  an inconsistent state?
\end{itemize}

Go does not support Java-style exceptions. Instead, it has the
\goType{error} type and the \goFunc{panic} functions. As a short
summary, Go's \goType{error}'s are ordinary values that can be
manipulated, passed as arguments and returned by functions. They are
analogous to Java's checked exceptions --- it is expected that the
caller of a function that returns an \goType{error} will check that
error in \goValue{nil}. A call to \goFunc{panic} is analogous to an
unchecked exception, and should only be used in a Go program when
something has gone unexpectedly wrong and the program should
terminate.

\todo{This section doesn't read very well. Could make a \textbackslash
  description with error and panic? Also don't forget to ref the
  listing.}

\begin{Listing}[hbtp]
\begin{lstlisting}
func main() {
    _, err := os.Create("/file/path")
    if err != nil {
        panic(err)
    }
    // Calculate results and write to file
}
\end{lstlisting}

  \mycaption{\goType{error} and \goFunc{panic}.}{In this case failure
    to create the file is sufficiently unexpected that we want the
    program to terminate.}
  \label{lst:interfaceTypes}
\end{Listing}

\subsection{Goroutines}
\label{sec:prep:goroutines}

Go supports goroutines, which are essentially light-weight threads. I
assume that the reader is familiar with threads, so instead of
explaining goroutines from scratch I will describe the main aspects in
which they differ from threads and that are relevant to this project:

\begin{itemize}
\item The only memory associated with a goroutine is its dynamically
  sized call stack. This is a lot cheaper than threads in Java, which
  have a large, fixed-size stack and associated objects holding state
  such as Thread ID and thread-local storage --- see Section
  \ref{sec:prep:thread-locals}.
\item Goroutines are anonymous. Go does not have a representation of a
  running goroutine analogous to Java's \javaClass{Thread} objects,
  and it is not possible in Go to stop or resume one goroutine from
  another.
\item Goroutines are multiplexed onto OS threads by the Go
  runtime. Because goroutines are so cheap to create and run, it is
  often practical to have very large numbers of goroutines running
  concurrently, even if the number of available processors and OS
  threads is small.
\end{itemize}

\subsection{Thread-local storage}
\label{sec:prep:thread-locals}

Java supports thread-local storage. As the name suggests, this is
storage that holds variables that differ between threads. Because in
an STM each transaction is running in its own thread, thread-local
storage can be used to keep any bookkeeping necessary by the
transaction. As an example, the JVSTM uses Java's
\javaClass{ThreadLocal}'s to keep the read- and write-sets necessary
to validate and commit read-write transactions --- see Section
\ref{sec:impl:read-sets-write}.

As mentioned in Section \ref{sec:prep:goroutines}, goroutines are much
more light-weight than Java's threads, and do not support thread-local
storage. When I started this project, I spent some time researching
ways to implement thread-locals. Thread-locals can be implemented by
using a thread ID, or in this case goroutine ID, as an index in a map
of ID to the corresponding thread-local state. However, as described
in Section \ref{sec:prep:goroutines}, goroutines are anonymous, and
there is not an appropriate way of determining the ID of a goroutine
--- the only ways are inefficient, ``hacky'' and generally frowned
upon\footnotemark.  \footnotetext{A brief, entertaining overview of
  this can be found at
  \URL{blog.sgmansfield.com/2015/12/goroutine-ids}}

\subsection{Locks in Go}
\label{sec:prep:locks-go}

Go's locks can be found in the \goCode{sync} package, and implement
the \goType{Locker} interface. The use of locks in this project is
restricted to the locking synchronisation approaches in STMBench7, but
it is worth noting that like Java, Go offers read-write locks, but
unlike Java, it does not offer reentrant locks as a consequence of the
light-weight support of goroutines.

\subsection{Memory model}
\label{sec:prep:memory-model}

Go's memory model defines a happens-before relationship between
synchronisation operations, similarly to Java's memory model. In Go,
the synchronisation operations are fewer: they mostly concern lock
acquisition, the creation of goroutines and channel communication. The
memory model lacks guarantees on shared memory accesses analogous to
the guarantees provided by Java's \javaCode{volatile} and
\javaCode{final} variables, on which the JVSTM relies to provide
synchronisation in a lighter-weight fashion than using locks.

Go's memory model lacks the formal semantics of more mature languages
\todo{Should probably cite some of Peter Sewell's work here. What
  would be a good paper to cite?}. That being said, the documentation
of the \goCode{sync/atomic} package seems to assume that its
operations have similar semantics to those of Java's
\javaCode{volatile} variables.

\section{Engineering methodology}
\label{sec:engin-meth}

\paragraph{Version control and backup policy.} I kept the source code
of my project in a Git repository publicly available on my GitHub
profile. The \LaTeX and accompanying source files of this dissertation
are in a private Git repository. In addition to the repositories
hosted on GitHub and the clones on my local machine, I kept a backup
of the contents of my local machine in an external disk, which I
updated weekly.

\paragraph{Test-driven development.} One of the lessons most ingrained
in me during my internship with Improbable was the benefit of using
test-driven development in software projects. However, because this
project involved designing an interface that was subject to change, it
made more sense to complete the implementation of the STM before
writing tests for it. During the implementation of STMBench7, the data
structure invariant tests were written as soon as possible to catch
any possible bugs early.

\paragraph{Tools.} I used the GoLand IDE to write, test and benchmark
my code. This dissertation was written using a \LaTeX package for
Emacs.  \todo{I should run go lint on the codebase.}

\paragraph{Versions and licenses.} I wrote my project using Go version
1.12. My implementation of the GVSTM is based on the original
description of the algorithm \cite{cachopo2007phd}. My implementation
of STMBench7 is based on the Java source code of the benchmark,
version 1.2, licensed under \todo{figure out what that license is...}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Implementation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Implementation}

In this chapter I will describe the implementation of both the GVSTM
and STMBench7, as well as the data structures and algorithms
involved. At the end of the chapter I include an overview of the
repository, for the interested reader to use as reference.

\section{Design decisions}
\label{sec:design-decisions}

\subsection{Typing}
\label{sec:typing}

Because Go does not offer generic programming, a user of the library
must use type casting when reading values from a transactional
variable. The return type of loads and the argument type of stores is
the empty interface.

\subsection{The \goFunc{Atomic} function}
\label{sec:atomic-function}

All reads and writes of transactional variables that occur inside a
call to Atomic appear to occur atomically and in isolation from other
transactions.

\subsection{Explicit transaction objects}
\label{sec:expl-trans-objects}

Because there are no thread-locals, transaction context must be passed
around explicitly.

\subsection{The ``transactional'' property}
\label{sec:cont-trans-prop}

Because transaction objects need to be passed around explicitly, and
because they are required to access a TVar, we can define
transactional functions inductively as:

\begin{enumerate}
\item A function is transactional if it reads or writes a TVAr.
\item A function is transactional if it calls a transactional function
  without surrounding said call in a call to Atomic.
\end{enumerate}

\subsection{Aborts using panics}
\label{sec:aborts-using-panics}

The user should not be aware of the inner workings of the STM, or
necessarily care that there is an internal distinction between
read-only and read-write transactions. The only way to immediately
abort a transaction without the user programming for it is to use a
panic.

\subsection{The interface pattern in STMBench7}
\label{sec:interf-patt-stmb}

I want object semantics pretty much everywhere in STMBench7, so the
interface pattern is extensively used, even if some interfaces have
only one implementation.

\section{GVSTM}
\label{sec:impl:gvstm}

\subsection{Versioned data structures}
\label{sec:impl:vers-data-struct}

VBoxes, VBodies. Basically a linked list and a wrapper. Lets
transactions read into the past.

\subsection{Conflicts}
\label{sec:impl:conflicts}

All types of memory conflicts. Which ones do we actually care about
--- RAW.

\subsection{Different methods of dealing with conflicts}
\label{sec:impl:diff-meth-deal}

Eager vs lazy conflict detection, eager vs lazy update.

JVSTM is lazy-lazy.

\note{Would it be worth mentioning here some results about the
  performance of different approaches?}

\subsection{Read-sets and write-sets to detect conflict}
\label{sec:impl:read-sets-write}

Describe the validation algorithm of the JVSTM.

\note{Is this a good place to mention memory allocation costs? The
  JVSTM allocates the memory for all VBodies at commit time. The GVSTM
  does it when the first write to a VBox is made. This shortens commit
  time, which is the concurrency bottleneck.}

\subsection{Read-only transactions}
\label{sec:impl:read-only-trans}

Only RAW conflicts are a problem. Because versioned data structures
allow reads of past values, read-only transactions can always read
consistent values, and hence never cause a conflict. This means that
read-only transactions always validate by construction, and hence do
not require the overheads of keeping read-sets and write-sets. This
means that read transactions in the GVSTM are extremely lightweight,
and pretty much always outperform locking approaches. This is always
the case in read-write workloads, because read-only transactions using
locks will often need to wait for a RW lock to be released by a
writer. It is still to an extent the case in read-only workloads
according to my results so far. I assume this is because the cost of
creating an empty transaction object in local cache is less than that
of acquiring a read-lock, which requires memory barriers.  \todo{Ref
  some section of the evaluation that supports this.}

\note{May be interesting to note that write-only transactions also
  never fail to validate, but in practice are very rare.}

\subsection{Flat nesting}
\label{sec:impl:flat-nesting}

Because nested transactions use the same transaction object we get
flat nesting.

\subsection{Garbage collection}
\label{sec:impl:garbage-collection}

\todo{Change title to something that makes it explicit this isn't
  general purpose GC. Something like GC of old versions.}

This is a requirement because versioned data structures keep a
history. The history needs to be truncated or else the program runs
out of memory.

\subsection{Extensions}
\label{sec:impl:extensions}

Here I discuss some extensions that could be made to the GVSTM. I did
not implement these extensions partly because of the time restrictions
on the project, and partly because STMBench7 does not leverage either
of them, so I would not be able to meaningfully evaluate
them. Nevertheless, these features increase the expressivity of STM
and could be implemented in future work.

\paragraph{Abort and retry semantics.}
\label{sec:impl:abort-retry-semant}

\paragraph{Different nesting semantics.}
\label{sec:impl:diff-nest-semant}

\paragraph{Side effects as monads.}
\label{sec:impl:side-effects-as}

The GVSTM only deals with access to transactional variables. If a
transaction does other types of side effects, such as printing to a
file or channel communication, those effects are not
transactional. One way this could be changed would be to represent
these effects as monads in the form of functions kept by the
transaction object. On commit, each of these monads is executed.

This solution only handles cases in which the transaction is producing
output. Much more careful thinking is required in the case where the
transaction consumes some input.

\section{STMBench7}
\label{sec:impl:stmbench7}

\subsection{Collection of results}
\label{sec:impl:collection-results}

To facilitate the collection of results, I changed the top level code
to output benchmark results to a file. Each run of the benchmark
creates a new file, whose name is the time at which the benchmark was
run and which contains information about the parameters used.

\subsection{Data structures}
\label{sec:impl:data-structures}

Include a diagram of the data structure, similar to the one in the
paper.

\subsection{Operations}
\label{sec:impl:operations}

Operations can fail due to operation logic. This is not due to
conflict or transactions aborting, but for example that ID pools are
empty or that a random traversal reached a base assembly with no
composite parts.This means that when looking at benchmark results it
makes sense to look at the total throughput and not only at the
throughput of successful operations.

\paragraph{Long traversals.}
\label{sec:impl:long-traversals}

\paragraph{Short traversals.}
\label{sec:impl:short-traversals}

\paragraph{Short operations.}
\label{sec:impl:short-operations}

\paragraph{Structure modification operations.}
\label{sec:impl:struct-modif-oper}

\subsection{Design patterns}
\label{sec:impl:design-patterns}

\note{Whoever wrote the Java version of STMBench7 probably swallowed a
  copy of the gang of four at some point. This makes the code a lot
  harder to understand for someone who hasn't, but makes it easier to
  extend and gives me a lot to write about in my dissertation. I could
  use this as a demonstration of CS/SWE knowledge.}

\paragraph{Factory method.}
There is a factory method for pretty much every type.

\paragraph{Abstract Factory.}
There are three abstract factories:

\begin{description}
\item[Design Objects] All the data structures described above. The
  GVSTM implementation uses TVars, the locking based implementations
  don't. The locking implementations are sequential, and locking is
  handled by the executors. The exception to this is the complex
  assembly implementation for MG locking, which requires acquiring
  some locks.
\item[Backend] This makes it easy to change the implementation of the
  underlying sets and such. Link this to providing a library of
  versioned data structures.
\item[Executors] This is actually just one factory method, but I
  turned it into a factory to be consistent with the others and with
  the Java version.
\end{description}

Bonus: the factories are singletons!

\paragraph{Builder.}

Builders are used to create and destroy the data structures, and
encapsulate the indexing of the objects in their respective indexes
and the creation of components, such as a document for composite
parts, children assemblies for a complex assembly, etc.

\paragraph{Executor.}

Executors are somewhat like the command pattern I believe?

\subsection{Testing}
\label{sec:impl:testing}

\paragraph{Invariant testing}
\label{sec:impl:invariant-testing}

Checking that some application level invariants on the data structures
and indexes are maintained.

These tests are actually useful: they helped me detect and fix a few
bugs when I was implementing the operations, both in my backend data
structure implementations and in some other places where I made silly
mistakes (eg. not checking for null value before casting, using
strings.HasSuffix instead of strings.HasPrefix).

\paragraph{Opacity testing}
\label{sec:impl:opacity-testing}

Checking that the parallel execution is equivalent to a sequential
execution.

This is essentially a property of the algorithm. Because I am using an
existing algorithm, for which opacity has been demonstrated, running
these tests would have little value.

Running these tests also increases the iteration time of running the
benchmark very significantly, because the multithreaded code needs to
be rerun sequentially.

Because the operations include randomness, this requires complicated
thread-local random state. This would be a lot of additional work for
little extra benefit, so I decided to spend my time on other
things. Good software engineering practice, huh?

\subsection{Extensions}
\label{sec:impl:possible-extensions}

\paragraph{Implementing all 45 operations.}
DONE: implement all the operations, instead of just a subset.

\paragraph{Efficient backend data structures.}

Make more efficient backend data structure implementations and see how
the performance changes.

\paragraph{Command line interface.}

Turn the benchmark into a proper CLI command, to make running it
easier.

\paragraph{Containerising.}
Make a Docker container with the benchmark, to be run on an AWS
instance with many more cores.

\paragraph{Rewrite the benchmark to be fairer.}
The method to create and register a complex assembly is unfair to
STMs: if the ID pool for either complex or base assemblies is
exhausted the method undoes all its work. This involves a lot of
operations on backend structures. Some STM implementations, such as
the GVSTM, could simply abort or retry when they detect such an error,
which would be much more efficient.

\section{Repository overview}
\label{sec:impl:repository-overview}

% \begin{figure}[h]
%   \centering \includegraphics{cuarms.pdf} \mycaption{Test
%   image.}{Kindly provided with the CL template.}
%   \label{fig:example}
% \end{figure}

% \begin{table}[h]
%   \centering
%   \begin{tabular}{| c | c |}
%     \hline
%     Float type & Working? \\
%     \hline
%     Figure & Check \\
%     Table & Check \\
%     Listing & Check \\
%     \hline
%   \end{tabular}
%   \mycaption{Test table.}{Shows whether the different types of
%   floats used are typeset as expected.}
%   \label{tbl:example}
% \end{table}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Evaluation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Evaluation}

In this chapter I recall the original goals of the project and
describe how they were achieved. I give quantitative results of
benchmarking the GVSTM with STMBench7 and qualitative conclusions from
using both locking approaches and the GVSTM to implement STMBench7. I
conclude with the real-world implications on the usability of the
GVSTM as an alternative to locking approaches in a variety of
scenarios.

\section{Success criteria}
\label{sec:eval:success-criteria}

\todo{Make sure to talk about testing.}

\section{Benchmark results}
\label{sec:eval:benchmark-results}

\todo{Talk bout engineering methodology, including
  \begin{itemize}
  \item Making sure ratio of failed operations is similar, so that
    results are not skewed.
  \item Benchmark run duration.
  \item Discarding outliers.
  \end{itemize}
}

\subsection{Metrics}
\label{sec:eval:metrics}

\paragraph{Total throughput.}

\paragraph{Maximum time to completion}

\paragraph{Time to completion histograms.}
May be interesting to show some histograms of TTC for some operation
types, but that may take up a lot of space. Could keep that in an
appendix.

\subsection{Impact of the number of threads}
\label{sec:eval:impact-numb-thre}

\subsection{Impact of structure modifications}
\label{sec:impl:impact-struct-modif}

Enabling structure modifications reduces throughput by more than one
order of magnitude for all synchronisation approaches.

\subsection{Workloads}
\label{sec:impl:workloads}

\paragraph{Read-only workload.}
\label{sec:impl:read-only-workload}

\paragraph{Read-dominated workload.}
\label{sec:eval:read-domin-workl}

\paragraph{Read-write workload.}
\label{sec:impl:read-write-workload}

\paragraph{Write-dominated workload.}
\label{sec:eval:write-domin-workl}


\subsection{Summary of results}
\label{sec:eval:summary-results}

Using the gvstm, long RW operations have very long TTCs, but read only
operations are not affected.

Using locking approaches, all operation types have similar TTCs. Can
relate this to different SLAs an application maintainer could have
with their users.

\section{Ease of use}
\label{sec:eval:ease-use}

\note{Due to the scope of this project, I couldn't do a usability
  study, so this is drawn from my own experience.}

\subsection{Implementing STMBench7}
\label{sec:eval:impl-stmb}

How easy it was to implement the executors:

\begin{itemize}
\item The GVSTM executor simply wraps the operation to execute in a
  call to Atomic.
\item The CG locking executor uses global read-write locks. When
  creating an executor for an operation, it determines whether it is
  read-only or read-write, and then acquires the appropriate lock
  before executing. Whether an operation is read-only or read-write is
  specified by the programmer, which has several problems:
  \begin{itemize}
  \item The approach does not allow the classification of arbitrary
    transactions that are not known at compile time. The GVSTM
    interface does not distinguish between RO and RW transactions and
    deals with that under the hood.
  \item Some transactions may perform some write operations in some
    executions but not others. Correct synchronisation would require
    these transactions to be classified as RW, which would make them
    perform worse than necessary when they happen to be RO.
  \item If someone misclassifies an operation as read-only, probably
    nothing fails in the program, but the results will be wrong
    because operations stop being atomic.
  \end{itemize}

\item The MG locking is much more complicated. It has read-write locks
  for each of several types of structures, as well as one read-write
  lock for each level of assemblies. I spent an afternoon fixing
  causes of deadlock and releases of not-acquired locks, even though I
  was pretty much only translating the algorithm. This shows how
  complicated programming with locks can be. (Part of the problem was
  that I forgot that the Java version uses reentrant locks, and Go
  does not have reentrant locks. I had to add some extra logic to make
  sure each lock is only acquired once.)
\end{itemize}

\subsection{Change of function signatures}
\label{sec:eval:change-funct-sign}

Any transactional function must receive a transaction object as an
argument. This means that it is difficult to use external libraries to
access shared memory transactionally, as the library would have to be
rewritten to pass around transaction objects.

A partial solution to this problem is the extension of making
transactional side effects using monads.

Locking would, to an extent, avoid this. That is, if only global locks
were used, the library need not know about any form of
synchronisation. However, as the implementation of the medium grained
locking approach has shown, an efficient locking approach will often
need more fine-grained control over locks, and locking state is passed
into the library.

\section{Real-world implications}
\label{sec:eval:real-world-impl}

Relate the results to real-world applications and SLAs that they may
have. The GVSTM offers extremely efficient read operations even in the
presence of writes, which locking approaches do not. It offers a
reasonably strong guarantee on the freshness of results of a read-only
transaction: if a read-only transaction begins after some other
transaction commits, the view of the read-only transactional will be
at least as fresh as the results of the committed transaction. This is
similar to linearisability.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Conclusion
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Conclusion}

\section{Achievements}
\label{sec:conc:achievements}

\section{Lessons learnt}
\label{sec:conc:lessons-learnt}

Overall the project went well, and I do not regret any of the
technical decisions made. For students looking to do similar projects
in the future, I would recommend including some means of evaluating
more complex features, such as the extensions described in the
implementation chapter. If possible, make use of existing benchmarks
and add your own.

\section{Future work}
\label{sec:conc:future-work}

Summary of the extensions described in the implementation chapter.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Bibliography
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\addcontentsline{toc}{chapter}{Bibliography} \bibliography{biblio}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Appendices
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\appendix

\chapter{Project Proposal}

\end{document}
