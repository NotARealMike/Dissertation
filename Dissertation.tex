%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% CL provided template
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[12pt,a4paper,twoside,openright]{report}

% turns references into hyperlinks
\usepackage[pdfborder={0 0 0}]{hyperref}

% adjusts page layout
\usepackage[margin=25mm]{geometry}

% allows inclusion of PDF, PNG and JPG images
\usepackage{graphicx}
\graphicspath{ {figs/} }

\usepackage{verbatim}

% try to avoid widows and orphans
\raggedbottom
\sloppy
\clubpenalty1000%
\widowpenalty1000%

% adjust line spacing to make more readable
\renewcommand{\baselinestretch}{1.1}

% add colour to TODOs
\usepackage{xcolor}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Maths
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage{amsmath}        % American Mathematical Society
\usepackage{amssymb}        % Maths symbols
\usepackage{amsthm}         % Theorems
\usepackage{mathpartir}    % Proofs and inference rules

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Floats
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage{float}
\usepackage[labelfont=bf,margin=10pt]{caption}
\usepackage{subcaption}
\newcommand{\mycaption}[2]{\caption[#1]{#1 #2}}

\floatstyle{plain}
\restylefloat{figure}
\restylefloat{table}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
% Figures
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage{tikz}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Tables
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage{array}
% control width and vertically align text in table cells
\newcolumntype{L}[1]{>{\raggedright\let\newline\\\arraybackslash\hspace{0pt}}p{#1}}
\newcolumntype{C}[1]{>{\centering\let\newline\\\arraybackslash\hspace{0pt}}p{#1}}
\newcolumntype{R}[1]{>{\raggedleft\let\newline\\\arraybackslash\hspace{0pt}}p{#1}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Listings
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage{fancyvrb}

\floatstyle{boxed}
%\floatstyle{ruled}
\newfloat{Listing}{tbp}{lol}[chapter]

\DefineVerbatimEnvironment{JavaCode}{Verbatim}
{fontfamily=courier,baselinestretch=1,gobble=4}

\DefineVerbatimEnvironment{GoCode}{Verbatim}
{fontfamily=courier,baselinestretch=1,gobble=4}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Semantic and convenience macros
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\TOBEDONE}{{\LARGE To be done...}}
\newcommand{\todo}[1]{\textcolor{red}{TODO: #1}}

\newcommand{\javaLiteral}[1]{\texttt{#1}}
\newcommand{\javaCode}[1]{\texttt{#1}}
\newcommand{\javaClass}[1]{\texttt{#1}}
\newcommand{\javaSlot}[1]{\texttt{#1}}
\newcommand{\javaVariable}[1]{\texttt{#1}}
\newcommand{\javaKeyword}[1]{\texttt{#1}}
\newcommand{\javaMethod}[1]{\texttt{#1}}
\newcommand{\javaException}[1]{\texttt{#1}}
\newcommand{\javaAnnotation}[1]{\texttt{#1}}

\newcommand{\goCode}[1]{\texttt{#1}}
\newcommand{\goType}[1]{\texttt{#1}}
\newcommand{\goVariable}[1]{\texttt{#1}}
\newcommand{\goKeyword}[1]{\texttt{#1}}
\newcommand{\goMethod}[1]{\texttt{#1}}

\newcommand{\keyTerm}[1]{\textbf{#1}}

\newcommand{\codeemph}[1]{\textbf{#1}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Info about dissertation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\disstitle}{Software Transactional Memory implementation
  and benchmarking in Go}
\newcommand{\college}{Churchill College}
\newcommand{\studentname}{Rui Cachopo}
\newcommand{\candidatenumber}{2239G}
\newcommand{\studentemail}{rmc82@cam.ac.uk}
\newcommand{\wordcount}{0000}
\newcommand{\loc}{0000}
\newcommand{\originator}{Rui Cachopo}
\newcommand{\supervisor}{Tim Harris}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Start of document
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\bibliographystyle{apalike}

\pagestyle{empty}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Cover page
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\rightline{\LARGE \textbf{\studentname}}

\vspace*{60mm}
\begin{center}
  \Huge
  \textbf{\disstitle} \\[5mm]
  Computer Science Tripos -- Part II \\[5mm]
  \college \\[5mm]
  \today
\end{center}

\newpage

\section*{Declaration}

I, \studentname\ of \college, being a candidate for Part II of the
Computer Science Tripos, hereby declare that this dissertation and the
work described in it are my own work, unaided except as may be
specified below, and that the dissertation does not contain material
that has already been used to any substantial extent for a comparable
purpose.

I, \studentname\ of \college, am content for my dissertation to be
made available to the students and staff of the University.

\bigskip \leftline{Signed: }

\medskip \leftline{Date: \today}

\chapter*{Proforma}

\thispagestyle{empty}

{\large
  \begin{tabular}{L{0.3\linewidth} L{0.7\linewidth}}
    Candidate number: & \bf \candidatenumber                      \\
    Project Title:      & \bf \disstitle \\
    Examination:        & \bf Computer Science Tripos -- Part II, July 2020  \\
    Word Count:         & \bf \wordcount  \\
    Lines of code : & \bf \loc \\
    Project Originator: & \originator \\
    Supervisor: & \supervisor \\
  \end{tabular}
}

\section*{Original Aims of the Project}

\section*{Work Completed}

All that has been completed appears in this dissertation.

\section*{Special Difficulties}
 
\tableofcontents

\pagestyle{plain} \pagenumbering{roman}

\listoffigures{}

\listoftables{}

\listof{Listing}{List of Listings}

\newpage

\section*{Acknowledgements}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% #Content
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\pagestyle{headings}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Intro
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Introduction}

\pagenumbering{arabic}

This dissertation describes the implementation and benchmarking of a
Software Transactional Memory (STM) in Go, a programming language that
emerged just as research on STMs dwindled. In this chapter I aim to
give a brief historical background of STMs and explain the choices I
made when proposing the project. In particular, I explain the choice
of STM algorithm, programming language and benchmark to use.

\section{Motivation and previous work}
\label{sec:motivation}

To have some context on the motivations behind STMs, it makes most
sense to first remember the historical trends in processor
design. From there, we can see how modern hardware limitations caused
a revolution in software and the problems that this caused to
programmers. Finally, we can see how STM tackles these problems.

\subsection{The problem}
\label{sec:problem}

Starting in the later half of the last century, and especially in the
period of 1986--2003, single-core processor performance grew
exponentially at such a rate that hardware became obsolete within one
or two years. This was mostly thanks to two ``laws'' of processor
design: Moore's law \cite{MooreLaw} and Dennard scaling
\cite{DennardScaling}. Moore's law is the observation that, due to the
production of smaller transistors, the number of transistors in a
processor doubles every two years\footnotemark. Dennard scaling states
that as transistors get smaller and consume less power, their power
density stays constant, so the power consumption of the whole
processor remains constant.

\footnotetext{The prediction in the 1965 paper was a doubling in
  transistor count every year, but this was revised in 1975 to a
  doubling every two years.}

The combination of these laws impacts processor performance in three
main ways:

\begin{itemize}
\item Smaller transistors can switch faster, meaning that the clock
  frequency of the processor can be increased.
  
\item The higher transistor budget allows for more complex hardware
  design. One way this was exploited was the use of pipelining, which
  reduces the critical path inside processor and allows the clock
  frequency of the processor to increase.
  
\item More complex hardware design was also used to build
  out-of-order, superscalar processors. These processors could exploit
  Instruction Level Parallelism (ILP) \cite[Chapter~3]{CompArchBook}
  latent in most programs.
\end{itemize}

This processor performance free lunch \cite{FreeLunchIsOver} ended in
the early 2000's, when Dennard scaling ceased to hold and the
low-hanging fruit of processor design had been harvested:

\begin{itemize}
\item In post-Dennard scaling, power consumption becomes a limiting
  factor in the complexity of a single core and on the clock frequency
  of the processor.
  
\item The performance penalties caused by interruptions, such as cache
  misses and mispredicted branches, increases with the length of the
  processor pipeline. This means deeper pipelines yield diminishing
  returns.
  
\item The amount of ILP latent in most programs is limited. This means
  that increasingly complex superscalar hardware will also yield
  diminishing returns.
\end{itemize}

As the limits of single-core performance and latent ILP were reached,
processor designers shifted their focus to multicore processors, which
are capable of exploiting Thread Level Parallelism (TLP)
\cite[Chapter~5]{CompArchBook}. As opposed to ILP, which is can be
automatically exploited by the processor in most applications, TLP is
much harder to automatically exploit. This means that the burden is
now on programmers to write concurrent applications if they want to
reap the benefits of increasing processor performance. Enter the
software revolution towards concurrent programming.

\subsection{Possible solutions}
\label{sec:possible-solutions}

The model most commonly used in concurrent programs consists of
multiple threads, which communicate through access to shared
memory. Low level primitives such as locks are used to provide
condition synchronisation and mutual exclusion when accessing shared
resources. This model is sufficient for simple programs, but it does
not scale to large applications. Problems such as deadlock and
priority inversion are hard to detect and debug in large programs. The
lack of a semantic link between a mutex lock and the resource it
protects leads to what Herlihy and Shavit call ``synchronisation by
convention'' \cite[Chapter 18]{ArtMultiprocessorProgramming}.

\begin{Listing}[hbtp]
  \begin{JavaCode}
    /* * * When a locked buffer is visible to the I/O layer BH_Launder
    * is set. This means before unlocking we must clear * BH_Launder,
    mb() on alpha and then clear BH_Lock, * so no reader can see
    BH_Launder set on an unlocked buffer * and then risk to deadlock.
    */
  \end{JavaCode}
  \mycaption{Synchronisation by convention.}{This Linux kernel comment
    demonstrates how real-world concurrent systems rapidly become
    complex.}
  \label{lst:syncConv}
\end{Listing}

Several approaches have been suggested as solutions to the problems
present when using locks and shared memory. The most basic of these is
the use of slightly higher level primitives, such as monitors and
condition variables. Java is a good example of this: the JVM
associates one monitor and one condition variable with each object. A
\javaKeyword{synchronized} code block runs inside a monitor, which can
be used to provide mutual exclusion. The condition variables can be
used for condition synchronisation using the \javaMethod{wait},
\javaMethod{notify} and \javaMethod{notifyAll} methods.

Moving away from threads and shared memory, other concurrency models
have been created. The most widespread involve message passing between
strongly isolated processes --- so called because, unlike threads,
they do not share memory. Hoare's Communicating Sequential Processes
\cite{CSP} and Milner's Calculus of Communicating Systems \cite{CCS}
are two formal models that use this idea. These models are mostly
employed by functional programming languages such as Erlang, which
allow no shared memory and in which all data is immutable. Concurrent
programs in these languages can be simpler to write and debug, but
often do not perform as well as programs written in more
``traditional'' languages such as Java and C\texttt{++}.

Yet another approach, and the focus of this dissertation, is
Transactional Memory (TM) \cite{TMBook}. When using transactional
memory, a programmer organises their code into transactions, similar
to the transactions in the transactional model of databases. It is
then up to the underlying TM implementation to provide atomicity and
isolation of the transactions executed. That is, the memory operations
of each transaction executed appear to all occur atomically, and no
transaction can see the results of a partial execution of any other
transaction.

Transactional memories provide a very simple interface to programmers:
to write a correct concurrent program, place all parallel code that
accesses shared data inside transactions, and let the underlying TM
ensure the program is correctly synchronised. Transactional memories
also provide composability, meaning it is simple to compose existing
transactions to achieve more complex behaviour. As an example,
consider that we want to dequeue an element from a concurrent queue
$Q_1$ and enqueue it in concurrent queue $Q_2$, but without any other
thread observing that the element is in neither or both queues at the
same time. Attempting to solve this problem with locks would be fairly
complex, involving either the inclusion of additional locks or the
exposition of internal locking logic of the concurrent queues. In a TM
model, however, the solution is trivial. This is discussed in more
depth in Section \todo{include section reference}.

Transactional memories can be implemented in hardware or
software. Hardware Transactional Memories (HTM) \todo{citation} are
usually implemented on top of the cache coherence protocol of a
processor, and are offered as an ISA extension. Because they operate
at such a low level, HTMs are often very efficient, but the size of
transactions is limited by the size of cache available and the
implementation cost is extremely high. Software Transactional Memories
(STM) \cite{STM} are much more flexible, but implementing them
efficiently can be a challenge. Efficiency concerns with regards to
STMs are so great that they have been called a ``research toy''
\cite{Toy}.

\section{Evaluation and benchmarking}
\label{sec:eval-benchm}

As mentioned above, performance is a crucial factor in the evaluation
of STMs. Although it has been shown that STM can largely outperform
sequential code in multicore computers \cite{MoreThanToy}, it falls to
each STM implementation to show that it is sufficiently efficient to
be adopted. With that goal in mind, it is important for the success of
this project to demonstrate how the STM implemented performs when
compared to alternatives, even if it does not outperform them.

With that in mind, I have chosen to include in the evaluation of my
STM the results of the STMBench7 benchmark, which can be regarded as a
stress test of STMs \cite{STMBench7}. STMBench7 aims to be a realistic
benchmark, meaning that instead of performing a long series of simple
transactions, such as reading and writing a handful of variables, it
performs elaborate operations on complex data structures. A
description of the benchmark and its data structures and operations
can be found in Section \todo{include section reference}.

As of the start of this project, there is no Go implementation of
STMBench7. This means that a considerable part of the work to be
completed, both in terms of lines of code written and time investment,
will consist of adapting the existing Java version to be implemented
in Go. Because of the complexity and size of the benchmark, my
proposal is to implement a subset of the original 45
operations. Completing the implementation of the benchmark is an
extension goal of the project.

\section{The STM chosen}
\label{sec:stm-chosen}

Although there has been substantial research on the topic of
transactional memory, and many STMs have been implemented, there are
few applications that actually use them. From a software engineering
perspective, there are many possible reasons for this, such as
adoption costs and little to no support of commonly used
libraries\todo{tentative, I don't actually know much about this}. One
of my goals in choosing my project was to develop an STM that could be
adopted in industry. This is, of course, a very ambitious objective
for the scope of this project, and is not a goal of the project
itself. Instead, I see this project as a starting point towards that
goal, and the possibility of further development can serve as an
aspect of evaluation.

With this long-term goal in mind, it made sense to base my project on
an existing STM with a real-world application. Such an STM is the Java
Versioned Software Transactional Memory (JVSTM) \cite{jvstm}, which
has been used in the FenixEDU project
\cite{carvalho2008versioned}. Because my STM uses the same version
box--based algorithm \cite{VBox} but is implemented in Go instead of
Java, I have decided to name it Go Versioned Software Transactional
Memory (GVSTM).

\section{Golang}
\label{sec:golang}

Go \cite{Go}, sometimes referred to as Golang, is a language whose
development started in 2007 in Google, and which was released in
2012. Go was designed with a focus on writing concurrent programs. Its
concurrency model is based on Hoare's CSP: multiple goroutines, Go's
version of coroutines, communicate through channels, which can be
blocking or buffered. Go also supports shared memory, as well as locks
and single-word atomic memory operations. The peculiarities of Go and
their implications on my project are discussed in Section
\todo{include section reference}.

One of the primary uses of Go has been to build server applications,
and there is a growing environment of tools and libraries to support
this. Examples are Docker and Kubernetes implementations, the etcd
key-value store system \cite{etcd}, the Elasticsearch-Logstash-Kibana
stack for logging \cite{ELK} and Prometheus for metric tracking
\cite{Prom}. One of my goals when choosing to use Go for this project
was to eventually contribute to this environment, and make it easy for
software engineers to build server applications using STM.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Preparation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Preparation}

\section{Go memory model and constraints}
\label{sec:go-memory-model}

\section{GVSTM}
\label{sec:prep:gvstm}

{ \em Work completed before code written:

  Explain prototype

  Define the API, relate to CMT and the desire for a standardised API,
  such as

  Understand the GC }

The preparation for this project is unusual in that a lot of research
was done prior to the start of the project. In fact, I built a working
prototype of the GVSTM and used it as a demonstration before proposing
this project to my supervisor.

\section{STMBench7}
\label{sec:prep:stmbench7}


\TOBEDONE

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Implementation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Implementation}

\TOBEDONE

The following is included in this draft to showcase the current
formatting of floats.

\begin{figure}[h]
  \centering \includegraphics{cuarms.pdf} \mycaption{Test
    image.}{Kindly provided with the CL template.}
\end{figure}

\begin{table}[h]
  \centering
  \begin{tabular}{| c | c |}
    \hline
    Float type & Working? \\
    \hline
    Figure & Check \\
    Table & Check \\
    Listing & Check \\
    \hline
  \end{tabular}
  \mycaption{Test table.}{Shows whether the different types of floats
    used are typeset as expected.}
\end{table}

\begin{Listing}
  \begin{JavaCode}
    class Account { long balance;
      
      Account(long balance) { setBalance(balance); } }
  \end{JavaCode}
  \mycaption{A non-thread-safe class \javaClass{Account} in Java with
    the basic \javaMethod{getBalance}, \javaMethod{deposit}, and
    \javaMethod{withdraw} operations.}{Some extra stuff here.}
  \label{lst:account}
\end{Listing}

\begin{Listing}
  \begin{GoCode}
    type activeTxRecord struct { txNumber uint64 bodiesToClean
      unsafe.Pointer running uint64 next *activeTxRecord }
  \end{GoCode}
  \mycaption{Example Go code.}{The \goType{activeTxRecord} type.}
  \label{lst:account}
\end{Listing}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Evaluation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Evaluation}

\TOBEDONE

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Conclusion
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Conclusion}

\TOBEDONE

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Bibliography
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\addcontentsline{toc}{chapter}{Bibliography} \bibliography{biblio}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Appendices
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\appendix

\chapter{Project Proposal}

\end{document}
